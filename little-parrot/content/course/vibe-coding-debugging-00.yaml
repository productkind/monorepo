course:
  id: a1b2c3d4-e5f6-7890-abcd-ef1234567890
  note: ''
  cover: "/courses/vibe-coding-debugging-00/cover.gif"
  title: 'Fix Bugs with Confidence: Debugging Your Lovable App'
  challenges:
  - title: The Anatomy of a Bug
    isFree: true
    skills:
    - Bug Definition
    - Debugging
    - Bug Types
    description: Understand what bugs are, how they are categorised, and develop the mindset to solve them effectively.
    completionTime: '8:00'
    steps:
    - type: comic
      content:
        imageUrl: "/comics/vibe-coding-debugging-00/panel-00.png"
    - type: comic
      content:
        imageUrl: "/comics/vibe-coding-debugging-00/panel-01.png"
    - type: comic
      content:
        imageUrl: "/comics/vibe-coding-debugging-00/panel-02.png"
    - type: comic
      content:
        imageUrl: "/comics/vibe-coding-debugging-00/panel-03.png"
    - type: text
      title: What is a bug?
      content:
        body: |-
          A **bug** is when your app behaves differently from what you intended. Maybe a button does not respond, data does not save, or the screen shows `"undefined"` instead of real content.

          The term comes from the early days of computing. *Grace Hopper*, a pioneering computer scientist, documented an incident where a moth got stuck inside a computer and caused it to malfunction. The team taped the insect into the logbook and wrote that they had **‚Äúdebugged‚Äù** the machine.

          Today, bugs are simply **mismatches between what you expected and what actually happens.**
        imageUrl: "/courses/vibe-coding-debugging-00/bug.png"
      subtitle: When reality doesn't match expectations
    - type: text
      title: Bugs are normal
      content:
        body: |-
          THIS WILL BE THE VIDEO
          When you build applications with AI app builders, things will sometimes break. Debugging is simply
          the process of finding and fixing those problems. In this micro-lesson, you‚Äôll learn practical
          techniques and core concepts to help you troubleshoot issues in AI-built applications. By the end,
          you‚Äôll be able to recognise common problems, identify their root causes, and fix them more
          effectively. Here‚Äôs something professional developers know well: bugs happen to everyone. Even
          experienced engineers spend much of their time fixing things that do not work as expected. Progress
          is not about being ‚Äútechnical enough‚Äù. It‚Äôs about knowing what to do when things go wrong or prevent
          them occurring on the first place. That‚Äôs exactly what this micro-course is designed to teach.
        imageUrl: "/courses/vibe-coding-debugging-00/bugs-normal.gif"
      subtitle: Every builder encounters them
    - type: text
      title: What is debugging?
      content:
        body: |-
          **Debugging** is the process of finding and fixing bugs. It has two parts:

          **1. Investigation:** Understanding what's wrong and why.

          **2. Fixing:** Making changes to solve the problem.

          Many beginners jump straight to fixing. But experienced developers know that **investigation is the most important part**. If you don't understand the problem, your fix might not work, or might break something else.

          This is true for vibe coding too! Effective debugging in Lovable means knowing how to investigate issues before trying to fix them.
      subtitle: The art of finding and fixing
    - type: text
      title: Types of bugs
      content:
        body: |-
          Bugs can be categorised in many ways. For our purposes, it makes sense to categorise them based on the action needed to fix them.

          Bugs typically fall into a few common categories:

          - **Launch blockers:** The app will not start or load, and you only see an error message.
          - **Freezes and misbehaviours:** The app starts, but specific features do not work as expected.
          - **Visual glitches:** Things look wrong, such as incorrect colours, or broken layouts.
          - **Security vulnerabilities:** Potential data leaks, unauthorised access threat, or other safety-related issues.

          Understanding these different scenarios can help you fix these bugs more quickly.
      subtitle: Different problems need different approaches
    - type: text
      title: "Types of bugs"
      content:
        body: |-
          Let ‚Äôs briefly explore each type of bug in the next steps. Some of them are so easy to
          fix that we cover them in this challenge right away. Others require more depth, so
          they get their own dedicated challenges later in the course.
      subtitle: Overview of bug categories
    - type: text
      title: "Types of bugs: Launch blockers"
      content:
        body: |-
          Launch blockers prevent your app from starting at all. In technical terms, these are known as **build errors** or **compile-time errors**.

          Build or compile time refers to the process of transforming your app‚Äôs code into a runnable program. If errors occur during this process, the app will not launch.
        imageUrl: "/courses/vibe-coding-debugging-00/error.gif"
      subtitle: When the app won't start
    - type: text
      title: "Types of bugs: Launch blockers"
      content:
        body: |-
          These errors can look intimidating, but they usually come with clear messages explaining what went wrong. Common causes include syntax errors, missing files, or incompatible code.

          Because these instructions are explicit and easy to interpret, and because AI is well suited to reading them, launch blockers are often the easiest bugs to fix.

          Lovable is even designed to automatically show a **Try to Fix** button when these errors occur, allowing you to resolve them quickly with a single click.

          If it doesn‚Äôt show the button, you can always prompt Lovable directly: `"There‚Äôs a build error: [paste error message]. Fix it."`
        imageUrl: "/courses/vibe-coding-debugging-00/build-error.webp"
      subtitle: When the app won't start
    - type: text
      title: "Types of bugs: Freezes and misbehaviours"
      content:
        body: |-
          These bugs occur when specific features or actions in your app do not work as expected. The app starts, but something goes wrong during use.
          In technical terms, these are often called **runtime errors** or **logical errors**.
          
          Runtime refers to when the app is running, and logical errors mean the code runs but produces incorrect results.

          Examples include:
          - A button that does nothing when clicked
          - Data that fails to save or load correctly
          - Features that behave inconsistently or unpredictably
        imageUrl: "/courses/vibe-coding-debugging-00/wrong.webp"
      subtitle: When features don't work as expected
    - type: text
      title: "Types of bugs: Freezes and misbehaviours"
      content:
        body: |-
          These bugs can be trickier to diagnose because they may not produce clear error messages. They often require careful investigation to understand the root cause.

          In this course, we'll focus heavily on these types of bugs, as they are the most common and challenging to resolve effectively.

          We will dedicate an entire challenge to mastering the investigation and fixing of these bugs.
      subtitle: When features don't work as expected
    - type: text
      title: "Types of bugs: Visual glitches"
      content:
        body: |-
          Visual glitches affect the appearance of your app. These bugs may involve incorrect colours, misaligned elements, or broken layouts.

          While they may not impact functionality directly, visual glitches can harm user experience and make your app look unprofessional.
        imageUrl: "/courses/vibe-coding-debugging-00/glitch.webp"
      subtitle: When things look wrong
    - type: text
      title: "Types of bugs: Visual glitches"
      content:
        body: |-
          In many cases visual glitches are not easily fixed by only prompting Lovable, but
          fortunately you can attach screenshots to your prompts to help Lovable understand exactly
          what is wrong.
        imageUrl: "/courses/vibe-coding-debugging-00/attach.png"
      subtitle: When things look wrong
    - type: text
      title: "Types of bugs: Security vulnerabilities"
      content:
        body: |-
          Security vulnerabilities are bugs that could potentially expose your app or its data to unauthorised access or malicious attacks.

          The features of your app could work perfectly well, but if there are weaknesses in how data is handled or protected, users' safety could be at risk.

          Software developers are auditing their code for security vulnerabilities all the time, as these problems can have serious consequences.
        imageUrl: "/courses/vibe-coding-debugging-00/lock.gif"
      subtitle: When safety is at risk
    - type: text
      title: "Types of bugs: Security vulnerabilities"
      content:
        body: |-
          While security vulnerabilities can be complex, Lovable helps you identify and fix many common issues.

          Lovable has a **built-in security auditor** that scans your app for potential vulnerabilities and suggests fixes.

          We dedicate an entire challenge in this course to understanding and addressing security vulnerabilities effectively.
      subtitle: When safety is at risk
    - type: quiz-question
      title: 'Quiz: What is a bug?'
      content:
        question: What best describes a bug in an app?
        options:
          - When the app crashes completely
          - When the app behaves differently from what you intended
          - When users do not like the design
          - When the code is too long
        correctAnswer: 1
        explanation: A bug is any mismatch between what you expect your app to do and what actually happens. It does not have to be a crash. Even small unexpected behaviours count.
    - type: quiz-question
      title: 'Quiz: Build errors'
      content:
        question: What is a build or compile-time error?
        options:
          - A visual issue that looks unpolished
          - A feature that behaves inconsistently
          - A bug that prevents the app from starting at all
          - A minor performance slowdown
        correctAnswer: 2
        explanation: These errors stop the app from loading entirely. They usually come with clear error messages in Lovable.
    - type: quiz-question
      title: 'Quiz: Fixing build errors'
      content:
        question: Why are build errors often the easiest bugs to fix?
        options:
          - They usually include clear error messages that AI can interpret well
          - They do not affect users
          - They fix themselves after a refresh
          - They only happen once
        correctAnswer: 0
        explanation: Build errors typically provide explicit messages about what went wrong. This makes them well suited for AI-assisted fixes, such as Lovable‚Äôs 'Try to Fix' feature.
    - type: quiz-question
      title: 'Quiz: Freezes and misbehaviours'
      content:
        question: Which of the following is an example of a freeze or misbehaviour?
        options:
          - The app fails to start and shows an error message
          - The layout is slightly off
          - A button does nothing when clicked
          - A missing image in the header
        correctAnswer: 2
        explanation: Freezes and misbehaviours happen at runtime. The app starts, but specific features do not behave as expected.
    - type: quiz-question
      title: 'Quiz: Visual glitches'
      content:
        question: What is a helpful way to debug visual glitches in Lovable?
        options:
          - Ignore them if the app works
          - Restart the app repeatedly
          - Prompt Lovable without any extra information
          - Attach screenshots to your prompt
        correctAnswer: 3
        explanation: Visual issues are easier to diagnose when you show Lovable exactly what looks wrong. Screenshots provide important context that text alone may miss.
    - type: reflection
      title: 'Reflection: Debugging mindset'
      content:
        description: What is one mindset shift you can make to approach bugs more effectively?
        placeholder: |-
          One mindset shift I can make is...
        subDescription: Effective debugging starts with the right mindset. Reflect on how you currently approach bugs and consider one change you can make to improve your process.
    - type: challenge-end
      title: "You've got the debugging mindset! \U0001F50D"
      content:
        nextModule: "**Next:** Prevention is better than cure! Learn powerful habits
          that dramatically reduce how often you encounter bugs."
        description: You understand what bugs are and how to approach them.
        subDescription: 'Remember: diagnose before you fix. Understanding the different types of bugs helps you to guide Lovable in fixing them more effectively. This mindset is the first step to becoming a debugging master \U0001F4AA. Great job!
          Now let''s learn how to prevent many bugs from happening in the first
          place!'
  - title: Preventing Bugs Before They Happen
    isFree: true
    skills:
    - Small Prompts
    - Testing
    - Version Bookmarking
    description: Learn simple habits that dramatically reduce frustrating bugs.
    completionTime: '10:00'
    steps:
    - type: text
      title: Prevention is easier than cure
      content:
        body: |-
          The best debugging strategy? **Avoid bugs in the first place!** While you can't prevent every bug, certain habits dramatically reduce how often you get stuck.

          Think of it like cooking: it's much easier to add salt gradually and taste as you go than to try to fix an over-salted dish. The same principle applies to building apps.
        imageUrl: "/courses/vibe-coding-debugging-00/wash-hand.gif"
      subtitle: Simple habits that save hours of frustration
    - type: text
      title: The small prompt habit
      content:
        body: |-
          One of the most common causes of bugs is asking for too much at once. When you give Lovable a huge, complex prompt, many things can go wrong, and it's hard to know which part caused the problem.

          **Instead of this:**
          "Add voting functionality with a vote button that increases the count, shows who voted, prevents double voting, sends notifications, and displays a leaderboard."

          **Try this:**
          "Add a Vote button next to each book suggestion that increases the count if pushed."

          Then test if it works as you intended. 
          
          Then add the next small piece.
      subtitle: One thing at a time
    - type: text
      title: Why small prompts work
      content:
        body: |-
          When you work in small steps:

          - **Bugs are easier to find.** If something breaks, you know it was the last small change you made.

          - **Bugs are easier to fix.** Less code changed means less to test and undo.

          - **You feel more in control.** Each small win builds confidence.

          Professional developers follow this same pattern. They call it "making small commits" ‚Äì completing and testing one small piece before moving to the next.
      subtitle: The wisdom behind the habit
    - type: text
      title: Test after every change
      content:
        body: |-
          After Lovable makes a change, **test it immediately**. Don't wait until you've added five more features.

          For Dalmie's voting feature, testing means:
          1. Click the Vote button
          2. Does the vote count increase on screen?
          3. Refresh the page ‚Äì is the vote still there?
          4. Try voting from a different account

          If something's wrong, you'll catch it while the change is fresh. Catching bugs early means they're much easier to fix.
        imageUrl: "/courses/vibe-coding-debugging-00/test.gif"
      subtitle: Catch bugs while they're fresh
    - type: text
      title: Bookmark your stable versions
      content:
        body: |-
          Lovable keeps a history of every change. You can **bookmark** working versions so you can always get back to them.

          **After every working feature:**
          Click the bookmark option to mark that version as stable.

          **Why this matters:**
          If a bug appears later, you have a known good state to return to. You can compare what changed between the working version and the broken one.

          **Pro tip:** If you use bookmarks and something in your app breaks, you can prompt Lovable:
          
          ```
          Compare the current version to the last bookmarked version. What has changed?
          ```
        imageUrl: "/courses/vibe-coding-debugging-00/bookmark-version.png"
      subtitle: Always have a safe point to return to
    - type: text
      title: Dalmie's prevention checklist
      content:
        body: |-
          When Dalmie adds a new feature to her Book Club Organiser, she now follows this checklist:

          ‚úì **One feature at a time.** First the Vote button. Then the vote count display. Then preventing double votes.

          ‚úì **Test immediately.** After each change, she clicks through her app to make sure it works as expected.

          ‚úì **Bookmark when it works.** Each stable version gets bookmarked.

          This simple routine has cut her debugging time dramatically. When bugs do appear, she knows exactly which change caused the issue.
      subtitle: A practical routine
    - type: text
      title: Aren't small prompts more expensive?
      content:
        body: |-
          It‚Äôs tempting to cram everything into one big prompt to save credits. In practice, this usually costs more.
          
          Large prompts increase the chance that something goes wrong, which leads to rework and wasted credits.
          
          Prompting Lovable in smaller, clearer steps is often cheaper overall. You get more predictable results, spot issues earlier, and avoid messy fixes.
          
          **Lovable is designed for iterative work.** A bit of back-and-forth while debugging is also normal.
          
          Don‚Äôt avoid building iteratively to ‚Äúsave‚Äù credits. A few well-spent credits to build in small steps can save many more later on.
      subtitle: Credits well spent
    - type: quiz-question
      title: 'Quiz: Small prompts'
      content:
        options:
        - To save credits by using fewer messages
        - Because Lovable can't handle complex prompts
        - To make the app run faster
        - To make bugs easier to find and fix
        question: Why is breaking features into small prompts helpful for preventing
          bugs?
        explanation: When you work in small steps, you always know what changed if
          something breaks. If a bug appears, it must be from the last small change,
          making it much easier to find and fix than hunting through a large, complex
          change. Also it makes sure that Lovable adds less unwanted functionality.
        correctAnswer: 3
    - type: quiz-question
      title: 'Quiz: Bookmarking'
      content:
        options:
        - Only at the very end when the app is complete
        - Once per day maximum
        - After every working feature is confirmed
        - Only when Lovable suggests it
        question: When should you bookmark a stable version?
        explanation: Bookmark after every working feature! Each bookmark is a safe
          point you can return to. If bugs appear later, you'll have clear checkpoints
          to revert to and can compare what changed between versions.
        correctAnswer: 2
    - type: free-text-exercise
      title: 'Practice: Break it down'
      content:
        description: Dalmie wants to add a comments feature where book club members
          can discuss each book suggestion. What are the best practices she should
          follow to prevent bugs while building this feature?
        placeholder: |-
          1. First, Dalmie should...

          2. Then she should...

          3. Next, she should...
        systemPrompt: |-
          You are a debugging mentor for writing applications using AI app builders like Lovable
          evaluating a best practice preventing bugs.

          ## Description for the assignment:

          Dalmie wants to add a comments feature where book club members
          can discuss each book suggestion. What are the best practices she should
          follow to prevent bugs while building this feature?

          ## Context for related content in the course:

          When Dalmie adds a new feature to her Book Club Organiser, she now follows this checklist:

          ‚úì **One feature at a time.** First the Vote button. Then the vote count display. Then preventing double votes.

          ‚úì **Test immediately.** After each change, she clicks through to make sure it works.

          ‚úì **Bookmark when it works.** Each stable version gets bookmarked.

          This simple routine has cut her debugging time dramatically. When bugs do appear, she knows exactly where to look.


          ## Assessment criteria:

          Good answers mention:
          (1) breaking the feature into small, testable parts
          (2) testing each part immediately after addition
          (3) bookmarking stable versions after each successful test. Praise systematic approaches.If they miss key prevention steps, suggest them.
          End with encouragement.

          ## Things to avoid:

          - Do not provide code or implementation details.
          - Don't mention version control systems outside of Lovable's bookmarking feature.
          - Don't mention too much besides the prevention habits taught in this challenge.
    - type: challenge-end
      title: "You've got the prevention habits! \U0001F6E1Ô∏è"
      content:
        nextModule: "**Next:** When bugs do happen, developers have specific techniques
          to investigate them. Let's learn how to find clues like a professional."
        description: You know how to reduce bugs before they happen.
        subDescription: Small prompts + immediate testing + bookmarked versions =
          fewer bugs and easier fixes. These habits will serve you throughout your
          building journey!
  - title: How Developers Investigate Bugs
    isFree: true
    skills:
    - Frontend Logs
    - Backend Logs
    - Network Tab
    - Status Codes
    - Function Invocations
    - Database Checking
    - Bug Reproduction
    - Stack Traces
    description: Learn the same investigation techniques that professional developers
      and the agent behind Lovable use.
    completionTime: '12:00'
    steps:
    - type: text
      title: Meet Dalmie's challenge
      content:
        body: |-
          Dalmie is building her Book Club Organiser app in Lovable. Yesterday, everything was working beautifully, members could suggest books for the book club.

          Today, she added a feature to be able to vote on each book. But now when she clicks the Vote button... nothing happens. No error message appears. The vote count doesn't change. The button looks normal.
        imageUrl: "/comics/vibe-coding-debugging-00/panel-04.png"
      subtitle: A debugging story
    - type: text
      title: The debugging mindset
      content:
        body: |-
          Let's shift how we think about bugs:

          **Old mindset:** "Something's broken. I must have done something wrong. Let me ask Lovable to fix it immediately."

          **New mindset:** "Something's not working yet. Let me understand what's happening before I try to fix it."

          The key insight: **diagnose before fixing**. Spending time investigating (rather than immediately attempting fixes) actually gets you to a solution faster.
      subtitle: Diagnose before you fix
    - type: text
      title: How developers investigate
      content:
        body: |-
          When professional developers encounter a bug, they don't guess. They gather clues systematically using specific techniques and tools.

          In this challenge, you'll learn the same **investigation techniques** that developers use ‚Äì and that Lovable uses too. Understanding these will help you to communicate with Lovable more effectively and fix bugs faster.
        imageUrl: "/courses/vibe-coding-debugging-00/spy.gif"
      subtitle: Gathering clues like a professional
    - type: text
      title: 'Frontend vs Backend: Where is the bug?'
      content:
        body: |-
          The first question developers ask: is this a **frontend** bug or a **backend** bug?

          The data flows through the frontend and backed part of the application, we would need to figure out which side the problem is on.

          **Frontend bugs** affect what users see:
          - Button doesn't respond to clicks
          - Text shows "undefined" or "NaN" instead of data
          - Layout looks broken
          - Colours or styles are wrong

          **Backend bugs** affect what happens behind the scenes:
          - Data doesn't save
          - User authentication fails
          - Information loads incorrectly
          - Actions succeed on screen but have no real effect

          Different bugs leave clues in different places.
      subtitle: The first question to ask
    - type: text
      title: Pinpointing the issue
      content:
        body: |-
          Beside the clues in the previous step, there are tools and strategies to help you investigate further.
          We need to check each part of the application to see where the problem lies, from the user interface
          (frontend) to the server and database (backend).
        imageUrl: "/courses/vibe-coding-debugging-00/checklist.gif"
      subtitle: A systematic approach
    - type: text
      title: 'Frontend logs: The browser Console'
      content:
        body: |-
          Your web browser has a secret superpower called **DevTools**. It includes a **Console** where your app writes messages and errors.

          **To open DevTools:**
          - **Windows/Linux:** Press `F12` or `Ctrl + Shift + I`
          - **Mac:** Press `Cmd + Option + I`
          - **Or:** Right-click anywhere on the page ‚Üí "Inspect"
          
          Then click the **Console** tab.

          When something goes wrong on the frontend, error messages appear here in red. Even when there's no visible error, the Console might contain clues.
        imageUrl: "/courses/vibe-coding-debugging-00/devtools.webp"
      subtitle: Where frontend errors appear
    - type: text
      title: What is the Console?
      content:
        body: |-
          The **Console** is like a diary for your app. It records:
          - Errors that occur
          - Warnings about potential issues
          - Messages you add the code to check what your app is doing at a specific moment

          Developers (and Lovable) use the Console **to see what went wrong** when bugs appear. Even if nothing seems broken on the screen, the Console might reveal hidden problems.
      subtitle: The app's diary of events
    - type: text
      title: Errors in software
      content:
        body: |-
          When code runs into a problem, it often throws an **error**, or also known as an **Exception**. Errors are like red flags that something went wrong.

          Usually an error looks like this in the Console:

          ```
          Uncaught TypeError: Cannot read properties of undefined (reading 'title')
              at renderBook (BookList.js:45)
              at onClick (VoteButton.js:10)
          ```
          The first line describes the error type and message. The lines below show where in the code the error occurred (called a **stack trace**).

          It can look scary, but you do not need to understand every detail. Simply knowing that an
          error occurred is already a big clue, and you can copy-past it for Lovable. 
          
          We are even happy to see it, because when we pass
          the error message to Lovable, it can often fix the problem straight away.
      subtitle: When code runs into problems
    - type: text
      title: Errors are you friend
      content:
        body: |-
          We advise you to read error messages carefully. They are your friends when debugging. At
          first, they may seem like gibberish, but there is a good chance they contain
          hints that help you understand what is wrong. Over time, you will also get better at
          reading error messages as you practise more.
      subtitle: Read the error messages
    - type: text
      title: How to produce the error messages
      content:
        body: |-
          To see error messages in the Console, you often need to **reproduce the bug** while DevTools is open.

          For Dalmie's Vote button bug:
          1. Open the **app preview** in a new tab
          2. Open **DevTools** (on that tab) and go to the **Console** tab
          3. **Click** the Vote button
          4. Look for any new **error messages** that appear in red

          If an error shows up, copy **the entire message** (including the stack trace) to share with Lovable. This information is crucial for diagnosing and fixing the bug.
    - type: text
      title: The Network tab
      content:
        body: |-
          In the DevTools, there is also a **Network tab**. This shows every request your app makes to the backend.

          Each row is a request. In the **Status** column, look for:
          - **200** ‚Äì Success, request worked
          - **400, 401, 403, 404, or 500** ‚Äì Failed, something went wrong

          **Clicking a failed request** shows details about what went wrong. This is especially useful for cases where nothing appears in the Console.

          **Dalmie's discovery:** When her Vote button did nothing, the Network tab showed a red `500` error on the vote request. This means, the backend crashed because something didn't work on the server.
        imageUrl: "/courses/vibe-coding-debugging-00/network-tab.png"
      subtitle: Watching backend communication
    - type: text
      title: HTTP status codes
      content:
        body: |-
          The frontend talks to the backend using **HTTP requests**. Each request gets a response with a **status code** indicating success or failure.
          Those numbers on requests (200, 401, etc.) are the **status codes**. Here are the important ones:

          **200** ‚Äî Success! Everything worked.

          **400** ‚Äî Bad request. The data sent was wrong or missing something.

          **401** ‚Äî Not authenticated. The user needs to log in.

          **403** ‚Äî Forbidden. User is logged in but doesn't have permission.

          **404** ‚Äî Not found. The thing requested doesn't exist.

          **500** ‚Äî Server error. Something crashed on the backend.

          The first digit tells you the category: 
          - **2xx = success**, 
          - **4xx = client problem**, 
          - **5xx = server problem**.

          If there is a failed request, it will likely also show up in the Console as an error message.
      subtitle: What the numbers mean
    - type: text
      title: Investigate further
      content:
        body: |-
          If the **Console** and **Network** tabs don't reveal the full issue, it's time to check the backend logs.

          **Backend logs** record what happens on the server side, so you cannot read them in the browser's console.

          In the next step, we'll explore how to access and interpret Lovable's backend logs.
        imageUrl: "/courses/vibe-coding-debugging-00/detective.gif"
    - type: text
      title: 'Backend logs: Lovable Cloud'
      content:
        body: |-
          When your app has backend functions, Lovable Cloud keeps logs of what happens.
          
          *(As a reminder, backend functions are pieces of code that run on the server to handle tasks like saving data, sending emails, or processing payments.)*

          **How to access the backend logs:**
          1. In Lovable, click the **`+` button** next to Preview
          2. Select the **Cloud tab**
          3. Click **Logs**

          **The logs show:**
          - When backend functions ran
          - What data they received
          - Any errors that occurred (the same type of error messages you saw in the Console)
          - Success or failure messages

          This is where you'll find clues for silent bugs that don't show errors in the browser.
        imageUrl: "/courses/vibe-coding-debugging-00/cloud-logs.webp"
      subtitle: Behind-the-scenes clues
    - type: text
      title: Function invocations
      content:
        body: |-
          In Lovable, in the **Cloud** tab, you can see **function invocations**. They are records of each time a backend function was called.

          You'll see entries like:

          - ‚úÖ `submit-vote` - Success (200)
          - ‚ùå `submit-vote` - Failed (500)
          - ‚ùå `submit-vote` - Failed (401)

          This tells you:
          - Was the function called at all? (Maybe the button isn't connected)
          - Did it succeed or fail?
          - What was the status code? (Tells you why it failed)

          Clicking an invocation often shows more details about what went wrong.
        imageUrl: "/courses/vibe-coding-debugging-00/invocations.webp"
      subtitle: Did the function even run?
    - type: text
      title: Checking your database
      content:
        body: |-
          Sometimes the function runs successfully, but data still seems wrong. The next place to check is the **database itself**.

          In the Lovable Cloud tab, you can view your database tables:
          1. Look for the **Database** section
          2. Click on the table you're investigating (e.g., `votes`)
          3. Check if the data you expected is actually there

          **Dalmie's discovery:** Her vote function showed "Success (200)" but votes weren't displaying. She checked the `votes` table and found her votes WERE being saved ‚Äì but with the wrong `book_id`. The bug was in what data was being sent, not in the saving process!
        imageUrl: "/courses/vibe-coding-debugging-00/database-check.webp"
      subtitle: Is the data actually there?
    - type: text
      title: Putting it all together
      content:
        body: |-
          When investigating bugs, follow this systematic approach:

          1. **Reproduce the bug** while DevTools is open.
          2. **Check the Console** for frontend errors.
          3. **Check the Network tab** for failed backend requests and status codes.
          4. If needed, **check Lovable Cloud logs** for backend function errors.
          5. Finally, **check the database** to see if data is saved correctly.

          Gathering clues from each of these places helps you pinpoint where the problem lies, making it much easier to fix.
      subtitle: A step-by-step investigation
    - type: text
      title: When there is no error message
      content:
        body: |-
          Not all bugs produce error messages. üò± Sometimes things just don't work as expected, but
          nothing appears in red.

          In these cases, you can prompt Lovable to add logging statements to your code. These are messages that print out
          internal state at key points, helping Lovable and you understand what's happening.

          After Lovable adds logs, reproduce the bug again and check the Console and Cloud logs for the new messages.

          In your prompt, be specific about what is the expected vs actual behaviour, so Lovable knows what to log.
      subtitle: Your debugging toolkit
    - type: quiz-question
      title: 'Quiz: The debugging mindset'
      content:
        options:
        - Immediately ask Lovable to fix the problem
        - Investigate what's happening before attempting fixes
        - Delete the feature and try again
        - Ignore the bug and hope users won't notice
        question: What's the most effective first response when you encounter a bug?
        explanation: Investigation first! Understanding what's actually happening
          before attempting fixes leads to better solutions and fewer wasted attempts.
          Jumping straight to fixes often makes things worse.
        correctAnswer: 1
    - type: quiz-question
      title: 'Quiz: Finding clues'
      content:
        options:
        - Lovable Cloud Logs
        - The Database
        - Click on Plan mode
        - 'Just prompt Lovable: ''It doesn''t work.'''
        question: Dalmie's Vote button does nothing when clicked, and there's no error
          in the Console or the Network Tab. Where should she look next?
        explanation: The next step is to check Lovable Cloud logs. Backend function errors
          often appear there when nothing shows up in the browser Console or Network
          tab.
        correctAnswer: 0
    - type: quiz-question
      title: 'Quiz: Status codes'
      content:
        options:
        - Success ‚Äì everything worked
        - The user is not authorised
        - Something crashed on the server
        - The data sent was wrong
        question: A request in the Network tab shows status code 401. What does this
          mean?
        explanation: 401 means 'Unauthorised' ‚Äì the user needs to be logged in but
          isn't, or their session has expired.
        correctAnswer: 1
    - type: quiz-question
      title: 'Quiz: Stack traces'
      content:
        options:
        - The entire error message including the stack trace
        - Only the file names
        - Only the line numbers
        - Just the button that caused the error
        question: What should you copy and share with Lovable when you see an error in the Console?
        explanation: Sharing the full error message, including the stack trace, gives Lovable the most useful context to diagnose and fix the issue quickly.
        correctAnswer: 0
    - type: quiz-question
      title: 'Quiz: When there is no error'
      content:
        options:
        - Keep clicking the button until it works
        - Rewrite the feature from scratch
        - Assume the bug will fix itself
        - Ask Lovable to add logging to inspect what is happening
        question: What should you do when a bug produces no error messages?
        explanation: When there are no visible errors, adding logging helps reveal what the code is actually doing. This makes invisible bugs visible and much easier to diagnose.
        correctAnswer: 3
    - type: free-text-exercise
      title: 'Practice: Investigation plan'
      content:
        description: |-
          Dalmie's Book Club Organiser has a bug: when she adds a new book, it shows on screen briefly, but disappears after she refreshes the page.

          Describe how she should investigate this bug. What places should she check, and in what order? What clues might she find?
        placeholder: |-
          1. First, Dalmie should check...

          2. Then she should look at...

          3. She might find...
        systemPrompt: 'You are a debugging mentor evaluating investigation plans for learners building digital products with Lovable ‚Äì the AI-development tool.
          Good answers mention: (1) checking the Network tab to see if the save request
          succeeded or failed and what status code, (2) checking Cloud logs to see
          if the backend function ran, (3) checking the database to see if the data
          was actually saved. The bug description suggests the save might not be working.
          Praise systematic approaches. If they miss key investigation steps, suggest
          them. End with encouragement.'
        checkerPrompt: 'I was given this task: ''Dalmie''s Book Club Organiser has
          a bug: when she adds a new book, it shows on screen briefly, but disappears
          after she refreshes the page. Describe how she should investigate this bug with Lovable.
          What places should she check, and in what order? What clues might she find?''
          Evaluate my answer in a helpful manner.'
    - type: challenge-end
      title: "You can investigate like a developer! \U0001F575Ô∏è"
      content:
        nextModule: "**Next:** Now that you know where to find clues, let's learn
          Lovable's specific debugging tools and when to use each one."
        description: You know where to find clues in the Console, Network tab, Backend Logs,
          and Database.
        subDescription: These investigation techniques are exactly what professional
          developers use. Now when you encounter a bug, you know where to look for
          clues before trying to fix anything!
  - steps:
    - type: text
      title: Lovable's debugging tools
      content:
        body: |-
          Lovable gives you three distinct debugging tools. Using the right one for a specific situation makes all the difference:

          - **Plan mode** ‚Äì For investigating problems and understanding what's wrong.
          - **Visual edits** ‚Äì For fixing how things look (colours, text, spacing).
          - **'Try to Fix' button** ‚Äì For quick automated repairs when errors appear.

          Let's explore each one in depth so you know exactly when to reach for which tool.
      subtitle: Three tools for three situations
    - type: text
      title: 'Plan mode: Your debugging partner'
      content:
        body: |-
          **Plan mode** or **Plan** transforms Lovable from a code generator into an investigative partner. This is your most powerful debugging tool.

          **How to access it:** Look at the bottom of your screen where you type prompts. You'll see a button that says "Plan". Click it to highlight **Plan** in blue.

          **The key difference:** In Plan mode, Lovable **investigates without changing your code** until you explicitly approve or click the **Plan** button again to switch back to **Agent** mode that writes code. This makes it safe for investigation ‚Äì you won't accidentally make things worse while exploring.
        imageUrl: "/courses/vibe-coding-debugging-00/chat-mode-location.png"
      subtitle: Investigation mode
    - type: text
      title: What Plan mode can do
      content:
        body: |-
          Plan mode can autonomously:

          - **Search through your files** to find relevant code
          - **Inspect logs** to see what happened
          - **Query your database** to check if data exists
          - **Reason through multi-step problems** and explain them

          When you describe an issue, Plan mode creates a step-by-step investigation plan. Once you're satisfied with the analysis, an **"Implement the plan"** button appears; clicking it switches to **Agent** mode and applies the fix.

          This **"investigate first, fix second"** approach embodies the debugging mindset!
      subtitle: Superpowers for investigation
    - type: text
      title: Effective Plan mode prompts
      content:
        body: |-
          Here are investigation prompts that work well:

          **For understanding what's wrong:**
          - ```The Vote button isn't working. Can you investigate what happens when it's clicked?```
          - ```What is the root cause of this error: [paste error from Console or Network tab]?```

          **For getting options before fixing:**
          - ```Investigate but don't write code yet. Suggest 3 possible causes.```
          - ```Take a step back. Analyse the problem and suggest a different approach.```
      subtitle: Prompts that work
    - type: text
      title: 'Visual edits: Point and click'
      content:
        body: |-
          **Visual edits** let you click directly on elements in your app preview and change their appearance instantly.

          **How to access it:**
          1. Look at the bottom of your screen where you type prompts
          2. Click the **Visual edits** button
          2. Click on any element in your app you want to change
          3. Type your prompt into the text box that appears

          **Best for:**
          - Changing colours, fonts, sizes
          - Fixing text content
          - Adjusting spacing and layout
          - Quick appearance tweaks

          **Bonus:** To change the text, you just need to click on the paragraph you want to edit in **Visual edits** mode and type the new text. It will cost no credits!
        imageUrl: "/courses/vibe-coding-debugging-00/visual-edit.webp"
      subtitle: For appearance issues
    - type: text
      title: 'Visual edits: Static vs dynamic'
      content:
        body: |-
          **Critical limitation:** Visually editing content only work on **static elements**.

          - **Static elements** stay the same for everyone: a logo, a heading that says "Welcome", a button labelled "Submit", a paragraph describing your team.

          - **Dynamic elements** change based on data or user state: a list of books from the database, a user's name after login, a vote count that updates.

          **How to tell:** Hover over an element in Visual edit mode. If you can't edit the text, it's dynamic.

          For dynamic elements, use Plan mode to investigate and fix.
          The design of both static and dynamic elements can be changed in Visual edits mode.
      subtitle: Know the limitation
    - type: text
      title: 'Try to Fix: Automated repair'
      content:
        body: |-
          When Lovable detects a specific error, a **Try to Fix** button may appear. Clicking it tells Lovable to automatically attempt a repair.

          **When it works well:**
          - Build errors
          - Missing dependencies
          - Error messages in Console or Cloud logs

          **When it doesn't work well:**
          - Silent bugs (no error to see)
          - Complex logic problems
          - Bugs requiring context or understanding

          **The three-attempt rule:** If 'Try to Fix' fails three times, stop and switch to **Plan mode** for proper investigation.
      subtitle: Quick fixes for clear errors
    - type: text
      title: 'Decision guide: Which tool?'
      content:
        body: |-
          **The button is the wrong colour**
          ‚Üí Visual edits (click and change it)

          **The button doesn't do anything when clicked**
          ‚Üí Plan mode (investigate the logic)

          **A red error appeared in your chat sidebar, after your last change**
          ‚Üí Try to Fix first (up to 3 times), then Plan mode

          **Data isn't saving correctly**
          ‚Üí Plan mode (investigate backend behaviour)

          **Text shows "undefined" instead of book titles**
          ‚Üí Plan mode (data isn't loading correctly)

          **Spacing looks weird on a static heading**
          ‚Üí Visual edits
      subtitle: Quick reference for tools in Lovable
    - type: quiz-question
      title: 'Quiz: What Plan mode is for'
      content:
        options:
        - Changing colours and fonts
        - Investigating issues without changing code
        - Automatically fixing errors without explanation
        - Editing database tables directly
        question: What can you use Plan mode for in debugging?
        explanation: Plan mode is useful for investigation. It lets Lovable search files, inspect logs, reason through problems, and explain what is happening without modifying your code until you approve a fix.
        correctAnswer: 1
    - type: quiz-question
      title: 'Quiz: Visual edits limitation'
      content:
        options:
        - The element is too small to click
        - The element is static
        - The element is dynamic (changes based on data)
        - The element is inside a button
        question: In Visual edits mode, Dalmie hovers over the book titles but can't
          edit them. Why?
        explanation: Book titles that come from the database are dynamic elements
          ‚Äì they change based on data. Changing the text with Visual edits only work on static elements like
          fixed headings or labels.
        correctAnswer: 2
    - type: quiz-question
      title: 'Quiz: Try to Fix'
      content:
        options:
        - When the layout looks wrong
        - When a clear error appears in the Console or Cloud logs
        - When a bug has no visible error
        - When Lovable explains you how the code works
        question: When does the 'Try to Fix' button appear in Lovable?
        explanation: "'Try to Fix' appears when Lovable detects a clear, specific error such as a build failure or an error message in the Console or Backend Logs."
        correctAnswer: 1
    - type: free-text-exercise
      title: 'Practice: Match tools to problems'
      content:
        description: |-
          For each bug Dalmie encounters, write which tool she should use (Plan mode, Visual edits, or Try to Fix) and briefly explain why:

          1. The "Add Book" button is grey but should be teal.
          2. After adding a book, it appears but disappears when she refreshes the page.
          3. A red "Build unsuccessful" error appeared after her last prompt.
          4. The list of books shows "undefined" for each title.
        placeholder: |-
          1. [Tool] because...

          2. [Tool] because...

          3. [Tool] because...

          4. [Tool] because...
        systemPrompt: 'You are a debugging mentor helping a learner match debugging
          tools to problems. Evaluate their answers: (1) Visual edits ‚Äî simple colour
          change on a static button, (2) Plan mode ‚Äî data not persisting is a backend/logic
          issue, (3) Try to Fix (up to 3 times) ‚Äî clear build error, (4) Plan mode
          ‚Äî undefined values suggest data loading issue. Provide friendly feedback
          in British English. Praise correct reasoning. Gently correct wrong answers
          with explanation. End with encouragement.'
        checkerPrompt: These are tool choices for four debugging scenarios.
    - type: challenge-end
      title: "You know your debugging toolkit! \U0001F9F0"
      content:
        nextModule: "**Next:** Sometimes fixing one bug creates another.
          Learn strategies to escape frustrating bug loops."
        description: You've learned when to use Plan mode, Visual edits, and Try to
          Fix.
        subDescription: Plan mode for investigation and logic bugs, Visual edits for
          static appearance changes, Try to Fix for clear errors (but only three times!).
          The right tool makes debugging much faster.
    title: Lovable's Debugging Toolkit
    isFree: true
    skills:
    - Plan Mode
    - Visual Edits
    - Try to Fix
    description: Master Lovable‚Äôs built-in tools to debug your projects. You‚Äôll understand
      what each one is useful for and how to use them to fix issues faster and keep
      moving forward.
    completionTime: '15:00'
  - steps:
    - type: text
      title: The dreaded bug loop
      content:
        body: |-
          The most frustrating experience: you try to fix something, but your fix breaks something else. So you fix that, which breaks the first thing again...

          You're stuck in a **bug loop** ‚Äì each fix attempt makes the codebase more tangled, and you feel like you're going backwards.

          This challenge teaches you specific strategies to escape this frustrating loop, and when to cut your losses and revert to a previous version.
        imageUrl: "/courses/vibe-coding-debugging-00/loop.gif"
      subtitle: When fixes break other things
    - type: text
      title: The three-attempt rule
      content:
        body: |-
          Here's a crucial lesson from experienced Lovable users: **if your fix attempts aren't working after three tries, stop and change your approach**.

          Each failed fix can make things worse by introducing new changes on top of broken code. You end up in a **bug loop** where fixes create new problems.

          After three attempts:
          - Revert to a previous working version
          - Switch to Plan mode to compare versions
          - Ask Lovable to explain the root cause before making more changes
          - Isolate the problem to one feature at a time
          - Rewrite the feature from scratch if it's too tangled

          We'll learn all these strategies in this course.
      subtitle: When to stop and rethink
    - type: text
      title: 'Strategy 1: The revert button'
      content:
        body: |-
          Every response in your chat history has a **revert option** underneath it. This is your emergency brake.

          **How it works:**
          Find the last response where things were working. Click the revert option. Your project goes back to that state. Any changes made after that point are undone.

          **What you don't lose:**
          All the messages and changes after that point remain visible in your history. You can read through them to understand what went wrong.

          **When to use it:**
          When you've made 3 fix attempts and things are getting worse, not better.
        imageUrl: "/courses/vibe-coding-debugging-00/revert-button.png"
      subtitle: Your emergency brake
    - type: text
      title: 'Strategy 2: Compare versions'
      content:
        body: |-
          If you're not sure what change caused the problem, switch to **Plan mode** and ask Lovable to compare:

          ```
          Compare the current version to the last bookmarked version. What changed? What might cause [describe the bug]?
          ```

          **Or:**

          ```
          Compare the code from 3 changes ago to now. List all the differences and which might cause [describe the bug].
          ```

          This surfaces exactly what changed, often revealing the culprit immediately. This is why bookmarking stable versions is so valuable!
      subtitle: Find what changed
    - type: text
      title: 'Strategy 3: Explain before fixing'
      content:
        body: |-
          When you're in a loop, stop asking for fixes. Switch to **Plan mode** and ask for explanation:

          ```
          We've been going back and forth on this bug. Before making any more changes, explain what might be the rootcause of [explain bug]. I want to understand before we proceed.
          ```

          This forces a step back. You might discover:
          - The approach itself is flawed
          - There's a simpler solution
          - Multiple bugs are tangled together
      subtitle: Understanding over action
    - type: text
      title: 'Strategy 4: Isolate the problem'
      content:
        body: |-
          Sometimes bugs are tangled together. Untangle them by isolating:

          ```
          Let's focus only on the Vote button for now. Ignore the vote count display, the leaderboard, and the notifications. Just get the Vote button to successfully save a vote.
          ```

          Once that works, add the next piece. This prevents fixes for one thing from breaking another.

          **Ask yourself:**
          - What's the simplest version of this feature that would work?
          - How can we disregard everything else and test just this one thing?
      subtitle: One thing at a time
    - type: text
      title: 'Strategy 5: Rewrite the feature'
      content:
        body: |-
          If a feature is deeply tangled, sometimes the fastest way forward is to rewrite it from scratch.
          You can **revert** not just before the bugloop started, but all the way back **to before the feature existed**.

          Then, prompt Lovable to build the feature again, but with a different approach or simpler design.

          Because building features with AI builders got so fast and cheap, **rewriting can be quicker than untangling**.
          It is literally less credits to start fresh than to spend hours debugging.
    - type: quiz-question
      title: 'Quiz: The three-attempt rule'
      content:
        options:
        - Keep trying the same fix until it works
        - Ask Lovable to apply bigger fixes
        - Ignore the bug for now
        - Stop and change your approach
        question: According to the three-attempt rule, what should you do after three failed fix attempts?
        explanation: After three attempts, continuing usually makes things worse. The rule exists to stop bug loops and encourage investigation, rethinking, or reverting instead of piling on more fixes.
        correctAnswer: 3
    - type: quiz-question
      title: 'Quiz: Using the revert button'
      content:
        options:
        - It deletes all later messages permanently
        - It rewinds the project to an earlier state
        - It fixes bugs automatically
        - It bookmarks the current version
        question: What does the revert button do?
        explanation: Reverting restores your project to a previous state while keeping the full history visible. This lets you undo bad changes without losing context.
        correctAnswer: 1
    - type: quiz-question
      title: 'Quiz: Choosing the right escape strategy'
      content:
        options:
        - Ask Lovable to investigate the rootcause of a broken feature before changing anything
        - Keep telling Lovable to fix the issue until the error disappears
        - Start a new project to rewrite the entire app
        - Ignore broken features and ship anyway
        question: You're stuck in a fix-break loop and no longer understand what's wrong. Which strategy should you try first?
        explanation: Asking for explanation before fixing forces a step back. It helps uncover flawed assumptions, tangled bugs, or simpler solutions before more changes are made.
        correctAnswer: 0
    - type: challenge-end
      title: "You can escape bug loops! ü™Ω"
      content:
        nextModule: "**Next:** Finally, let's master the art of communicating with
          Lovable to get bugs fixed effectively."
        description: You have strategies for when things get stuck.
        subDescription: Revert, compare, explain before fixing, isolate, and know
          when to start fresh. These escape routes will save you hours of frustration.
          Sometimes going back is the fastest way forward!
    title: Escaping Bug Loops
    isFree: true
    skills:
    - Revert
    - Version Comparison
    - Problem Isolation
    - Fresh Starts
    description: Learn specific strategies to escape frustrating fix-break-fix cycles.
    completionTime: '9:00'
  - steps:
    - type: text
      title: From clues to fixes
      content:
        body: |-
          You've learned to investigate bugs and find clues. Now let's learn how to communicate those findings effectively so Lovable can actually fix the problem.

          The way you write your debugging prompts makes a huge difference in how quickly you get to a solution.
        imageUrl: "/courses/vibe-coding-debugging-00/disaster.gif"
      subtitle: Communicating for effective fixes
    - type: text
      title: The debugging prompt formula
      content:
        body: |-
          Structure your debugging prompts like this:

          **1. What you were doing**
          "I clicked the Vote button on a book suggestion."

          **2. What you expected**
          "The vote count should increase by 1."

          **3. What actually happened**
          "Nothing changed on screen."

          **4. The clues you found**
          "The Network tab shows a 401 error on the vote request."

          **5. What you've tried (if anything)**
          "I tried logging out and back in, but same result."

          This formula works for almost any bug!
      subtitle: The structure that works
    - type: text
      title: Be specific about location
      content:
        body: |-
          Always mention exactly where the bug happens:

          ‚ùå "The button doesn't work."

          ‚úÖ "On the `/books` page, the Vote button next to each book suggestion doesn't respond when clicked."

          **Include:**
          - The page URL or name (`/dashboard`, `/books`)
          - The specific component ("the Vote button", "the Add Book form")
          - Any relevant context ("for books with zero votes", "when logged in as a member")

          Vague prompts lead to vague fixes. Specific prompts lead to precise solutions.
      subtitle: Where exactly is the problem?
    - type: text
      title: Include guardrails
      content:
        body: |-
          Tell Lovable what NOT to touch. This prevents fixes from breaking other working features:

          "Fix the vote count display on the book cards. **Do not modify:**
          - The navigation component
          - The authentication system
          - The Add Book form"

          **Or more simply:**
          "Fix the voting issue. Only change files related to the vote button, don't touch other components."

          Guardrails keep fixes focused and prevent the bug loops we discussed in the previous challenge.
      subtitle: Protecting working code
    - type: text
      title: Share the clues you found
      content:
        body: |-
          Remember all those investigation techniques? Share what you found:

          **Console errors:**
          "The Console shows this error: `Cannot read properties of undefined (reading 'votes')`"

          **Network tab findings:**
          "The Network tab shows the vote request failing with a 401 status."

          **Database discoveries:**
          "I checked the database and the votes ARE being saved, but with the wrong book_id."

          **Log observations:**
          "The Cloud logs show the function is being called but returning an error: [paste error]."

          These clues help Lovable pinpoint exactly where to look.
      subtitle: Your investigation results matter
    - type: text
      title: Asking Lovable to add logs
      content:
        body: |-
          When you need more visibility into what's happening, ask Lovable to add temporary logging:

          "The vote isn't saving but I can't figure out why. Can you add console logs to the vote submission process so I can see:
          1. What data is being sent when the button is clicked
          2. What response comes back from the backend
          3. Any errors that occur"

          **After adding logs:**
          1. Reproduce the bug
          2. Check the Console for the new messages
          3. Share what you find with Lovable

          This gives you step-by-step visibility into what's happening.
      subtitle: Getting more visibility
    - type: text
      title: When you're frustrated
      content:
        body: |-
          If standard approaches aren't working, communicate the context:

          "I'm frustrated because we've tried three different approaches to fix this voting bug and none have worked. Before making any more changes, please:
          1. Analyse what we've tried so far
          2. Explain why each approach might have failed
          3. Suggest a completely different approach"

          This signals that the situation needs extra care and encourages deeper analysis rather than more quick fixes.
      subtitle: Communicate when stuck
    - type: text
      title: Complete debugging prompt example
      content:
        body: |-
          Here's a complete example putting it all together:

          "## Bug

          On the `/books` page, when I click the Vote button on a book suggestion, nothing happens.

          **Expected:** Vote count increases by 1.

          **Actual:** No change on screen.

          **Clues:** The Network tab shows the vote request returning 401. The Console has no errors. I'm logged in ‚Äì I can see my name in the header.

          **Tried:** Refreshing the page, logging out and back in ‚Äì same result.

          Can you investigate what's causing the 401 error? Please don't modify the login system or navigation ‚Äì just focus on the voting function."

          This gives Lovable everything needed to investigate and fix effectively.
      subtitle: Putting it all together
    - type: quiz-question
      title: 'Quiz: Debugging prompts'
      content:
        options:
        - '"On /books, clicking Vote returns a 401 error. Expected: count increases.
          Actual: nothing happens. Please don''t touch the auth system."'
        - '"Fix the bug please."'
        - '"Something''s broken with voting I think."'
        - '"The vote thing doesn''t work sometimes."'
        question: Which debugging prompt would get the fastest, most accurate fix?
        explanation: Specific location + expected behaviour + actual behaviour + clues
          found + guardrails = effective debugging prompt. The more specific information
          you provide, the faster Lovable can find and fix the issue without breaking
          other things.
        correctAnswer: 0
    - type: quiz-question
      title: 'Quiz: The debugging prompt formula'
      content:
        options:
        - Only what is broken
        - What you clicked and what error appeared
        - Expected behaviour, actual behaviour, and clues found
        - A long description of the entire app
        question: Which elements make up an effective debugging prompt?
        explanation: The most effective prompts clearly state what you did, what you expected, what actually happened, and any clues you found. This structure dramatically improves fix quality.
        correctAnswer: 2
    - type: quiz-question
      title: 'Quiz: Guardrails'
      content:
        options:
        - They prevent Lovable from making any changes at all
        - They are required for all prompts
        - They make the fix process slower
        - They keep fixes focused and prevent breaking working features
        question: What's the purpose of including guardrails ("don't modify X") in
          debugging prompts?
        explanation: Guardrails keep fixes focused on the problem area. Without them,
          Lovable might modify working code while trying to fix the bug, potentially
          creating new problems. This is especially important when escaping bug loops!
        correctAnswer: 3
    - type: free-text-exercise
      title: 'Practice: Write a complete debugging prompt'
      content:
        description: |-
          Dalmie's Book Club Organiser has a bug: The "Add Book" form submits successfully (she sees a success message), but the new book doesn't appear in the list. She checked the database and the book IS saved with correct data. She's on the `/books` page logged in as an organiser.

          Write a complete debugging prompt using the formula we learned.
        placeholder: Write your debugging prompt here...
        systemPrompt: 'You are a debugging mentor evaluating debugging prompts. A
          good prompt includes: location (/books page), user role (organiser), what
          happens (form submits, success message shows), what''s wrong (book doesn''t
          appear in list), clues found (data IS in database ‚Äî so this is a display/fetch
          issue, not a save issue), and ideally guardrails. Praise complete, well-structured
          prompts. If missing elements, suggest additions. End with encouragement.'
        checkerPrompt: This is a debugging prompt for a book that saves to the database
          but doesn't appear in the list.
    - type: reflection
      title: Your debugging journey
      content:
        description: Think about everything you've learned in this micro-course. Which
          technique or concept do you think will be most valuable for you? How will
          you apply it in your next building session?
        placeholder: |-
          The most valuable thing I learned is...

          I plan to use it by...
        subDescription: Writing this down helps cement the learning. You've built
          real debugging skills that professional developers use every day!
    - type: course-end
      title: "Congratulations! You're a debugging-capable builder! \U0001F389"
      content:
        nextModule: "**Your next step:** Return to your project with fresh confidence.
          When your next bug appears (and it will!), you'll know exactly what to do.
          Investigate first, find clues, and communicate clearly with Lovable. You've
          got this!"
        description: Look at everything you've learned!
        subDescription: "‚úì **The debugging mindset:** Diagnose before fixing, follow
          the three-attempt rule, and recognise different types of bugs.\n\n‚úì **Prevention
          habits:** Small prompts, immediate testing, and bookmarking stable versions.\n\n‚úì
          **Investigation techniques:** Browser Console, Network tab, Cloud logs,
          function invocations, and database checking ‚Äì the same tools developers
          use.\n\n‚úì **Lovable's toolkit:** Plan mode for investigation, Visual edits
          for appearance, and Try to Fix for clear errors.\n\n‚úì **Escape strategies:**
          Revert, compare versions, isolate problems, and know when to start fresh.\n\n‚úì
          **Effective communication:** The debugging prompt formula, guardrails, specificity,
          and asking for logs.\n\n**Remember:** Every professional developer debugs
          constantly. You now have the same toolkit they use. The bugs will come,
          but so will the fixes. Happy building! \U0001F4AA"
    title: How to Guide Lovable to Fix Bugs
    isFree: true
    skills:
    - Debugging Prompts
    - Guardrails
    - Specificity
    - Adding Logs
    description: Master the art of communicating with Lovable to get bugs fixed effectively.
    completionTime: '14:00'
  titleSplit:
  - 'Fix Bugs with Confidence:'
  - Debugging Your Lovable App
  description: Learn to find and fix bugs confidently, even without technical knowledge.
    No more panic when things go wrong!

